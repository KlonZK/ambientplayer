
local versionNum = '0.21'

function widget:GetInfo()
  return {
    name      = "Ambient Player",
    desc      = "v"..(versionNum).." a very basic ambient sound mixer",
    author    = "Klon",
    date      = "dez 2014",
    license   = "GNU GPL, v2 or later",
    layer     = -1,
    enabled   = true,
  }
end	

local READPATH_DEFAULT = 'sounds/ambient/'
local WRITEPATH_DEFAULT = 'LuaUI/Configs/'
local UIPATH_DEFAULT = 'LuaUI/'
local PLAYLIST_DEFAULT = READPATH_DEFAULT..'ambientplaylist.lua'
local SAVETABLE_FILE = UIPATH_DEFAULT..'Utilities/savetable.lua'
local LUADIR = LUAUI_DIRNAME
local ROOTDIR = './'
local PLAYLIST_HEADER = ''
local SOUNDITEM_TEMPLATE = {
	file = "",
	gain = 1.0,
	pitch = 1.0,
	pitchMod = 0.0,
	gainMod = 0.05,
	priority = 0,
	maxconcurrent = 2, 
	maxdist = math.huge, 
	preload = true,
	in3d = true,
	rolloff = 0,
	rnd = 0,
	length = 10, -- this is arbitrary, needs manual setting
	offset = 0,			
	timeframe = 1,
	generated = true			
}

local readFolder = READPATH_DEFAULT
local writeFolder = WRITEPATH_DEFAULT

local PlaySound= Spring.PlaySoundFile
--local PlayStream= Spring.PlaySoundStream
local Echo = Spring.Echo
local random=math.random

local updateIntervalSeconds = 1.0
local secondsToUpdate = 0.1
local gameStarted = Spring.GetGameFrame() > 0
local inited = false

local tracks
local ambientVolume = 1.0
local verbose = true
local autoplay = false

local SaveTable, MakeSortedTable, CompareKeys, valueTypes, keyTypes, encloseKey, encloseStr, keyWordSet, keyWords, saveTables, indendtString

local words = {

		["RD"] = 	{
						get = function () return READPATH_DEFAULT end,
						set = function (s) return false end,
					},
		["WD"] = 	{
						get = function () return WRITEPATH_DEFAULT end,
						set = function (s) return false end,
					},
		["UI"] = 	{
						get = function () return UIPATH_DEFAULT end,
						set = function (s) return false end,
					},
		["$"] = 	{
						get = function () return ROOTDIR end,
						set = function (s) return false end,
					},		
		["rd"] =	{
						get = function () return readFolder end,
						set = function (s) readFolder = s return true end,
					},
		["wd"] =	{
						get = function () return writeFolder end,
						set = function (s) writeFolder = s return true end,
					},
		["ui"] =	{
						get = function () return LUADIR end,
						set = function (s) LUADIR = s return true end,
					},	
		}	

words.get = function(wrd)
	local word = wrd:sub(2) -- cut off the $
	if (word == "") then return wrd end
	if (words[word]) then
		if (words[word].get) then return words[word].get()
		else return words[word]
		end
	else
		return wrd
	end
end		

words.set = function(word, s)
	if (word == "") then return false end
	if (words[word]) then
		if (words[word].set) then return words[word].set(s)
		else words[word]=s return true
		end
	else
		words[word] = s
		return true
	end
end		


function widget:Initialize()	
	if VFS.FileExists(PLAYLIST_DEFAULT, VFS.RAW_FIRST) then
		
		if (Spring.LoadSoundDef(PLAYLIST_DEFAULT)) then
		--Echo("Loaded Ambient Sound Defs successfully")
		else
			Echo("<ape>: failed to load playlist")
			--Destroy()
		end
		
		local tracklist = {}
		tracklist,ambientVolume = VFS.Include(PLAYLIST_DEFAULT, nil, VFS.RAW_FIRST)		
		ambientVolume = ambientVolume or 1.0
		
		if (tracklist.Sounditems == nil) then
			Echo("<ape>: playlist was empty")
			--Destroy()			
		else
			tracks=tracklist.Sounditems
			for track, params in pairs (tracks) do
				params.timeframe=secondsToUpdate+params.offset
				params.generated=false
			end
		end		
	else
		Echo("<ape>: no playlist found")
		tracks = {}
		--Destroy()		
	end
	
	if VFS.FileExists(SAVETABLE_FILE, VFS.RAW_FIRST) then
			
		SaveTable, MakeSortedTable, CompareKeys, valueTypes, keyTypes, encloseKey, encloseStr, keyWordSet, keyWords, saveTables, indendtString
			= VFS.Include(SAVETABLE_FILE, nil, VFS.RAW_FIRST)		
		Echo("<ape>: loaded savetable.lua")
	else
		Echo("<ape>: failed to load savetable.lua")
	end
	
	inited=true
end



function widget:Destroy()	
end

function widget:GameStart()
	gameStarted = true
end

function widget:Update(dt) 	
	if not (gameStarted) then return end
		
	if (secondsToUpdate>0) then
		secondsToUpdate=secondsToUpdate-dt
		return
	else
		secondsToUpdate=updateIntervalSeconds
	end
	
	if not (autoplay) then return end
	
	for track, params in pairs (tracks) do		
		if (params.rnd > 0) then --skip disabled tracks entirely
			params.timeframe=params.timeframe-updateIntervalSeconds	
			if (params.timeframe < 0) then
				params.timeframe=0			
				if (random(params.rnd)==1) then
					DoPlay(track,ambientVolume)
					params.timeframe=params.length+params.offset				
				end
			end	
		end	
	end	
end

function DoPlay(track, vol) 
	if not (tracks[track]) then
		Echo("<ape>: track not found!")
		return false
	else
		local tr=track
		if (tracks[tr].generated) then	tr=tracks[tr].file	end
		if (PlaySound(tr, vol)) then
			if (verbose) then
				Echo("<ape>: playing "..track.." at volume: "..string.format("%.2f", vol))
			end
			return true		
		end	
		Echo("<ape>: playback of "..track.." failed, not an audio file?")
		return false
	end
end

function widget:TextCommand(command)		
	if (command:sub(1,3)== "ap.") then	
		local args = ParseInput(" "..command:sub(4))
		if (args) then
			for k, v in pairs(args) do
				Echo(k.."> "..v)
			end
		Invoke(args)
		end		
	end			
end

function ParseInput(s)	
	local i = 1
	local args = {}
	
	s = string.gsub (s, "(%$%w+)", words.get) -- words encapsulated in other words will not get resolved	
	
	repeat
		local sq, eq = string.find (s, "[%(%[].-[%)%]]")	--start, end of a bracket block
		if not (sq or eq) then
			sq, eq = string.find (s, "[\"\'].-[\"\']")	--start, end of a quote block
		end
		Echo (sq, eq)
		if (sq or eq) then
			if (sq and eq) then
				--while (s:sub(sq,sq) == " ") do sq = sq + 1 end
				local ss = s:sub(1, sq - 1)	-- get all arguments before the block
				for a in string.gmatch(ss, "%s+(%S+)") do 
					args[i] = a
					i = i + 1
				end
				args[i] = s:sub(sq + 1 , eq -1) -- get the argument in the block
				i = i + 1
				s = s:sub(eq + 1)
				--sq = string.find (s, "[\'\"%(%[]")	 
			else
				Echo("<ape>: illegal argument(s) - lone bracket")
				return {}
			end
		else break end	
	until (false)
	
	for a in string.gmatch(s, "%s+(%S+)") do
		Echo(a)
		args[i] = a
		i = i +1
	end
	return args
end	

function Invoke(args)
	
	-- manipulation of playlist table items
	if (args[1] == "set") then

		if (args[2]) then 
		-- disallow editing non-existant items, to avoid creating bogus items
		
			if not (SOUNDITEM_TEMPLATE[args[2]]) then
				Echo("<ape>: unrecognized property")
				return false
			else
			
				if (args[3]) then
								
					if not (tracks[args[3]]) then
						Echo("<ape>: cannot find target!")
						return false
					end
					
					if (args[4]) then
					
						--local tipe = type(tracks[args[3]][args[2]])
						local tipe = type(SOUNDITEM_TEMPLATE[args[2]]) --read from the template instead
						--Echo("parameter of type: "..tipe)						
						if (tipe == "string") then
							tracks[args[3]][args[2]]=tostring(args[4])
							
						elseif (tipe == "boolean") then
							if (args[4] == "true") then 
								tracks[args[3]][args[2]]=true
							elseif (args[4] == "false") then
								tracks[args[3]][args[2]]=false
							else
								Echo("<ape>: only true/false allowed for this value")
								return false
							end
							
						elseif (tipe == "number") then
							local number = tonumber(args[4])
							if (number) then
								tracks[args[3]][args[2]]=number
							else
								Echo("<ape>: not a number")
								return false
							end							
						end						
						Echo("param: "..args[2].." target: "..args[3].." set to: "..tostring(tracks[args[3]][args[2]]))
						return true
						
					else
						Echo("<ape>: no value specified")
						Echo("param: "..args[2].." target: "..args[3].." is: "..tostring(tracks[args[3]][args[2]]))
						return false
					end
					
				else
					Echo("<ape>: no target specified")
					return false
				end
				
			end	
			
		else
			Echo("<ape>: no arguments specified")
			return false
		end
		return false
	end
	
	-- play a sounditem, by name
	if (args[1] == "play") then								
		if (args[2]) then			
			local vol
			if (args[3]) then vol = tonumber(args[3])	end
				vol=vol or ambientVolume			
			return DoPlay(args[2], vol)							
		else
			Echo("<ape>: specify a track")
			return false
		end
	end
	
	-- load a single sound file from the read folder and generate a table entry for it
	-- if no name for the entry was specified, it will use that files name after a '$'
	-- file can then by accessed by that name, and that name only
	-- arguments:
	-- file: mandatory
	-- name to use in the playlist: optional, defaults to filename
	-- length in seconds: optional: optional, defaults to 10
	-- offset in seconds: optional, defaults to 0
	-- rnd as play once per <rnd>seconds on average: optional, defaults to 0 (disabled)
	-- timeframe(seconds to next playback): optional, defaults to 1
	if (args[1] == "load") then		
		if (args[2]) then
			if (args[3]) then
				if (tonumber(args[3])) then -- skip name if none was supplied, but numbers
					return LoadFromFile(readFolder, args[2], nil, args[3], args[4], args[5], args[6])
				end
			end
			return LoadFromFile(readFolder, args[2], args[3], args[4], args[5], args[6], args[7])			
		else
			Echo("<ape>: specify a file in "..readFolder)
			return false
		end		
	end
	
	
	-- if the player will announce titles when playing
	if (args[1] == "verbose") then
		verbose = not (verbose)
		if (verbose) then
			Echo("<ape>: verbose on")
		else 
			Echo("<ape>: verbose off")
		end
		return true
	end
	
	-- general volume control
	if (args[1] == "vol") then	
		local number = tonumber(args[2])
		if (number) then			
			if (number < 0) then ambientVolume = 0
			elseif (number > 2) then ambientVolume = 2
			else ambientVolume=number
			end
			Echo("<ape>: set ambient volume "..string.format("%.2f",ambientVolume))
			return true
		end
		Echo("<ape>: not a number")
		return false
	end	
	
	-- echo whole playlist or display single item properities
	if (args[1] == "list") then
		
		i = 2
		while (args[i]) do
			if (tracks[args[i]]) then
				Echo("<ape>: ---"..args[i].."---")
				for param, value in pairs(tracks[args[i]]) do
					Echo(tostring(param).." : "..tostring(value))
				end				
			else			 
				Echo("<ape>: no such track: "..args[i])
			end	
			i = i + 1			
		end	if (i>2) then return true end
		
		Echo("<ape>: ---playlist---")
		for track, params in pairs (tracks) do
			if not (params.rnd) then params.rnd = 0 end -- failsafe
			if (params.rnd > 1) then
				Echo("Random "..(params.rnd)..": "..track.." - "..(params.length).."s")
			elseif (params.rnd == 1) then
				Echo("Loop: "..track.." - "..(params.length).."s")
			else 
				Echo("Disabled: "..track.." - "..(params.length).."s")
			end
		end
		return true
	end
	
	-- pause playlist
	if (args[1] == "hold") then
		autoplay = not (autoplay)
		if (autoplay) then
			Echo("<ape>: play")
		else 
			Echo("<ape>: hold")
		end
		return true
	end

	-- show contents of a directory
	-- with no arguments it shows the root of the VFS
	-- 'read' and 'write' will show read- and write directory variables respectivly
	-- otherwise the argument will be taken as a path
	if (args[1] == "dir") then
		
		if not (args[2]) then
			Echo("<ape>: you must specify a path")
			return false
		end
		
		local pattern = "."
		if (args[3]) then
				pattern = string.gsub (args[3], "[%.%*]", {["."] = "%.", ["*"] = ".+" })
				--if (pattern == "%." or pattern == ".+%.") then pattern = "[^%.]" end
		end
				
		local path=args[2]			
		if not (path:sub(-1) == ('/' or '\\')) then	path=path..'/'	end		
		
		local files = VFS.DirList(path)
		local subdirs = VFS.SubDirs(path)		
		
		Echo ("----- "..path.." -----")		
		for dir, text in pairs(subdirs) do
			if (pattern == "%." or pattern == ".+%.") then
				if (string.match(text, "[%.]")) then Echo(text) end
			else
				if (string.match(text, pattern)) then Echo(text) end
			end	
		end
		for file, text in pairs(files) do
			if (pattern == "%." or pattern == ".+%.") then
				if not (string.match(text, "[%.]")) then Echo(text) end
			else
				if (string.match(text, pattern)) then Echo(text) end
			end	
		end
		return true
	end
	
	
	if (args[1] == "save") then	
	
		if (args[2]) then --path/file
			if (args[3]) then --type
				if (string.match (args[3], "^[emitters]$") then
						
				elseif (string.match (args[3], "^[options]$") then
				
				elseif (string.match (args[3], "^[playlist]$") then
				
				else
					Echo("<ape>: type must be: e..., p..., o...")
					Echo("(emitters, playlist, options)")
				end
			else
				Echo("<ape>: saving all to "..args[2])
						
		else
			Echo("<ape>: saving all to write dir...")
		end	

		return false	
	end
	
	--defunct
	if (args[1] == "map") then
		if (args[2]) then
			if VFS.MapArchive(args[2]) then
				Echo("success") 
				return true
			end
				
		end
		Echo("failure")
		return false
	end
	
	if (args[1] == "env") then
		if (args[2]) then
			Echo("\n-------"..args[2].."--------")
			--local file = io.open("G.txt", "w")
			---[[
			local G = getfenv()
			local i = 0
			if not (G[args[2]]) then return end
			for k, v in pairs(G[args[2]]) do
				--file:write("key: "..k.." str:"..tostring(k).." val"..tostring(v).."\n")
				--if not (type(k) == 'table') then
				Echo (tostring(k))
				--end
				i=i +1
				if (i==10000) then break end
			end
			--]]
			Echo(words.get("$read"))
			--file:close()
		end	
	end

	if (args[1] == "def") then
		if (args[2]) then
			if (args[3]) then
				return words.set(args[2], args[3])				
			end		
		else
			Echo ("----- ".."defines".." -----")	
			for k,v in pairs(words) do 
				if (type(v) == 'table') then
					Echo('$'..k.." -> "..v.get())
				elseif (type(v) ~= 'function') then
					Echo('$'..k.." -> "..v)
				end
				
			end
		end
	end
	Echo("<ape>: not a valid command")
	
end


function LoadFromFile(folder, file, name, length, offset, rnd, timeframe)
	
	Echo("<ape>: loading "..file.." ...")
	if VFS.FileExists(folder..file) then	
	
		local ending=file:sub(-4,-1)
		if not (ending=='.ogg' or ending =='.wav') then
				Echo("<ape>: must be *.wav or *.ogg!")
			return false
		end

		local shortname = name or ("_"..file:sub(1,-5))
		
		if not (tracks[shortname] == nil) then
			Echo("<ape>: a sounditem with that name already exists!")
			return false		
		else 		
			if not (PlaySound(folder..file, 0)) then -- preload the file and generate sounditem
					Echo("<ape>: unable to load file. not a soundfile?")
					return false
			end 		
			
			tracks[shortname]={}			
			for param, value in pairs (SOUNDITEM_TEMPLATE) do
				tracks[shortname][param] = value				
			end				
			
			tracks[shortname].file=folder..file			
			tracks[shortname].length=tonumber(length) or tracks[shortname].length
			tracks[shortname].offset=tonumber(offset) or tracks[shortname].offset
			tracks[shortname].rnd=tonumber(rnd) or tracks[shortname].rnd
			tracks[shortname].timeframe=tonumber(timeframe) or tracks[shortname].timeframe
			
			Echo("<ape>: added playlist entry: "..shortname)
		end							
	else 
		Echo("<ape>: file not found!")
		return false
	end
	Echo("<ape>: loaded "..file.." successfully!")
end

function SavePlaylist(file) 
	
	if not (file) then
		--file=SAVETABLE_FILE --silly
	end
	
	local gentracks = {}
	for item, params in pairs(tracks) do
		if (params.generated) then	
			gentracks[item]=true	
			params.generated=false
		end
	end
	
	local dumdum = {}
	dumdum.Sounditems = tracks	
	
	WriteTable(dumdum, file, 'Sounds', PLAYLIST_HEADER)
	--table.save(dumdum,file)
	
	for item, params in pairs(tracks) do
		if (gentracks[item]) then	
			params.generated=true			
		end
	end
	
end

function WriteTable(t, filename, tname, header)

	if not (filename) then 
		Echo("<ape>: you must specify a file")
		return false 
	end
	
	Echo("<ape>: saving "..filename.." ...")
	local file = io.open(filename, 'w')
	
	if (file == nil) then 
		Echo("<ape>: failed to open "..filename)
		return false 
	end
	
	if (header) then file:write(header..'\n') end
	
	file:write('local '..tname..' = ')
	SaveTable(t, file, '')
	file:write('}\nreturn '..tname)
	
	file:close()
	Echo("<ape>: done!")
end
